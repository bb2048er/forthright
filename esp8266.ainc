
/* These are ESP8266 macros to read and write to DataRAM addresses.
 *
 * The DataRAM variables should be declared as
 *
 *     DECL_VAR my_variable, 64, 4       // my_variable occupies 64 bytes of RAM and need 4-byte alignment
 *
 * and can then be manipulated
 *
 *      READ_VAR a8, my_variable        // Read the first element in the DataRAM area into register a8
 *      WRITE_VAR a8, my_variable + 4   // Write the a8 register to the second 32bit element in the DataRAM area.
 */

	.macro DECL_VAR name, space, align
	.literal .ADDR_\name, \name
	.data
	.comm \name, \space, \align
	.endm

	.macro VAR_ADDR reg, address
	l32r \reg, .ADDR_\address
	.endm

	.macro READ_VAR reg, address
	l32r \reg, .ADDR_\address
	l32i \reg, \reg, 0
	.endm

	.macro WRITE_VAR reg, free_reg, address
	l32r \free_reg, .ADDR_\address
	l32i \reg, \free_reg, 0
	.endm

/* The Forth environemnt is passed to assembler in a C struct,

	typedef struct
	{
		void* data_segment;
		int data_segment_size;

		void* data_stack;
		int data_stack_size;

		void* return_stack;
		int return_stack_size;

		void* input_buffer
		int input_buffer_size;

		void* word_buffer
		int word_buffer_size;
		void* word_buffer_ptr;
		int word_buffer_counter;
	} system_t;

	and on the ESP8266 C-compiler the address of that is passed to the entry point in the
	a2 register. All members of the struct are 4 byte aligned.

	To access the members in the system_t struct use the macro defined below with the offsets defined below.

	The following definitions sets the offsets within the C struct.
*/
	.equ	system_t_data_segment, 0
	.equ	system_t_data_segment_size, 4
	.equ	system_t_data_stack, 8
	.equ	system_t_data_stack_size, 12
	.equ	system_t_return_stack, 16
	.equ	system_t_return_stack_size, 120
	.equ	system_t_input_buffer, 24
	.equ	system_t_input_buffer_size, 32
	.equ	system_t_word_buffer, 36
	.equ	system_t_word_buffer_size, 40
	.equ	system_t_word_buffer_ptr, 44
	.equ	system_t_word_buffer_counter, 48

	.macro ENV reg, member
	l32i \reg, a12, \member
	.endm

	.macro PUT_ENV reg, member
	s32i \reg, a12, \member
	.endm

/* ESP8266 doesn't push the return address automatically when it does a call to somewhere else. Instead
 * it simply places the return address in register a0. If the routine doesn't make any further calls, no
 * stack will be used, but it becomes the called routines problem to save the return stack if it calls
 * any further methods.
 * This macro is only to be used when subroutines calls other subroutines. The native Forth words don't
 * need to use this macro, as they operate at the same stack level, and keeps a0 and a1 unchanged.
 */
	.macro SAFE_CALL label
	addi sp, sp, -4			// adjust stack pointer
	s32i a0, sp, 4			// save return address
	call0 \label			// call C putChar()
	l32i a0, sp, 4			// get the saved return address
	addi sp, sp, 4			// restore stack pointer
	.endm
